package main

import (
	"errors"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/PuerkitoBio/goquery"
	runtime "github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ses"
	"go.uber.org/zap"
)

type config struct {
	Page            string
	Product         string
	SoldOutString   string
	AddToCardString string
	SendEmailTo     string
	Session         *session.Session
	Log             *zap.SugaredLogger
}

func newConfig() config {
	c := config{
		Page:            os.Getenv("PAGE"),
		Product:         os.Getenv("PRODUCT"),
		SoldOutString:   os.Getenv("SOLD_OUT_STRING"),
		AddToCardString: os.Getenv("ADD_TO_CARD_STRING"),
		SendEmailTo:     os.Getenv("SEND_EMAIL_TO"),
	}

	logger, _ := zap.NewProduction()
	defer logger.Sync() // flushing buffer?
	c.Log = logger.Sugar()

	c.Session = session.New()

	if c.Page == "" {
		c.Log.Fatal("Page not set")
	}
	if c.Product == "" {
		c.Log.Fatal("Product not set")
	}
	if c.SoldOutString == "" {
		c.Log.Fatal("SoldOutString not set")
	}
	if c.AddToCardString == "" {
		c.Log.Fatal("AddToCardString not set")
	}
	if c.SendEmailTo == "" {
		c.Log.Fatal("SendEmailTo not set")
	}
	return c
}

func (c *config) SubjectString() string {
	return fmt.Sprintf("%s is available again!", c.Product)
}

func (c *config) BodyString() string {
	return fmt.Sprintf("%s is available for purchase on %s. This was generated on %v\n\nGenerated by automated AWS Lambda service.", c.Product, c.Page, time.Now())
}

func main() {
	runtime.Start(handleRequest)
}

func handleRequest() error {
	c := newConfig()

	// Fetch page
	res, err := http.Get(c.Page)
	if err != nil {
		c.Log.Errorf("Unable to fetch page: %v", err)
		return err
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		c.Log.Errorf("Page fetch status: %d", res.StatusCode)
		return err
	}

	// Check if the string contains the "SoldOut" string
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		c.Log.Errorf("Unable to build the doc from Body: %v", err)
		return err
	}

	var (
		spanRes   []string
		soldOut   int
		buttonRes []string
		emailSent bool
	)

	// find SoldOut
	doc.Find("span").Each(func(i int, s *goquery.Selection) {
		spanRes = append(spanRes, s.Text())
	})

	for _, v := range spanRes {
		if v == c.SoldOutString {
			soldOut += 1
		}
	}

	// find AddToCard
	doc.Find("button").Each(func(i int, s *goquery.Selection) {
		buttonRes = append(buttonRes, s.Text())
	})

	if soldOut == 0 && len(buttonRes) > 0 {
		ok := c.sendEmail()
		if !ok {
			return errors.New("Unable to send the email")
		}
		emailSent = true
	}

	c.Log.Infof("Checked the %s. Email status: %v (true - product is available, false - product is unavailablee", c.Product, emailSent)
	return nil
}

func (c *config) sendEmail() bool {
	svc := ses.New(c.Session)

	result, err := svc.SendEmail(c.buildEmail())
	if err != nil {
		c.handleErrors(err)
		return false
	}

	c.Log.Infof("Return from email send: %v", result)
	return true
}

func (c *config) buildEmail() *ses.SendEmailInput {
	return &ses.SendEmailInput{
		Destination: &ses.Destination{
			ToAddresses: []*string{
				aws.String(c.SendEmailTo),
			},
		},
		Message: &ses.Message{
			Subject: &ses.Content{
				Charset: aws.String("UTF-8"),
				Data:    aws.String(c.SubjectString()),
			},
			Body: &ses.Body{
				Text: &ses.Content{
					Charset: aws.String("UTF-8"),
					Data:    aws.String(c.BodyString()),
				},
			},
		},
		ReturnPath:    aws.String(""),
		ReturnPathArn: aws.String(""),
		Source:        aws.String("sender@example.com"), // TODO: Change that to AWS provided env var
		SourceArn:     aws.String(""),
	}
}

func (c *config) handleErrors(err error) {
	if aerr, ok := err.(awserr.Error); ok {
		switch aerr.Code() {
		case ses.ErrCodeMessageRejected:
			c.Log.Fatalf("Error: %v\nDetails: %v", ses.ErrCodeMessageRejected, aerr.Error())
		case ses.ErrCodeMailFromDomainNotVerifiedException:
			c.Log.Fatalf("Error: %v\nDetails: %v", ses.ErrCodeMailFromDomainNotVerifiedException, aerr.Error())
		case ses.ErrCodeConfigurationSetDoesNotExistException:
			c.Log.Fatalf("Error: %v\nDetails: %v", ses.ErrCodeConfigurationSetDoesNotExistException, aerr.Error())
		case ses.ErrCodeConfigurationSetSendingPausedException:
			c.Log.Fatalf("Error: %v\nDetails: %v", ses.ErrCodeConfigurationSetSendingPausedException, aerr.Error())
		case ses.ErrCodeAccountSendingPausedException:
			c.Log.Fatalf("Error: %v\nDetails: %v", ses.ErrCodeAccountSendingPausedException, aerr.Error())
		default:
			c.Log.Fatalf("Error: %v", aerr.Error())
		}
	} else {
		c.Log.Fatal(err)
	}
}
